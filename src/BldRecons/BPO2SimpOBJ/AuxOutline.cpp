#include "StdAfx.h"
#include "AuxOutline.h"
#include "ParamManager.h"

CAuxOutline::CAuxOutline(void)
{
	m_pOutline = NULL;
}

CAuxOutline::~CAuxOutline(void)
{
}

void CAuxOutline::RegisterOutline( COutline * outline )
{
	m_pOutline = outline;
	m_vecLine.clear();
	m_vecLineIndex.clear();
	m_vecLineIndex.resize( outline->m_vecVertex.size(), -1 );
}

void CAuxOutline::ProduceOutline( COutline & outline )
{
	CParamManager * manager = CParamManager::GetParamManager();

	outline.m_cPlane = m_pOutline->m_cPlane;
	outline.m_vecVertex.clear();

	std::vector< int > line_loop;
	std::vector< bool > line_touched( m_vecLine.size(), false );

	int touched_num = 0;
	int num = ( int )m_vecLine.size();
	int v_pointer = 0;
	while ( touched_num < num ) {
		int idx;
		for ( idx = 0; idx < num; idx++ ) {
			if ( !line_touched[ idx ] )
				break;
		}

		line_loop.clear();
		line_loop.push_back( idx );
		line_touched[ idx ] = true;
		idx = Line_NextLineIndex( idx );

		while ( idx != line_loop[ 0 ] ) {
			line_loop.push_back( idx );
			line_touched[ idx ] = true;
			idx = Line_NextLineIndex( idx );
		}
		touched_num += ( int )line_loop.size();

		if ( ( int )line_loop.size() < 2 )
			continue;

		// first pass, produce vertices
		// v[i] is generated by intersecting l[i] & l[i.next]
		for ( int i = 0; i < ( int )line_loop.size(); i++ ) {
			int line_idx = line_loop[ i ];
			int inext = line_loop[ ( i + 1 ) % ( int )line_loop.size() ];

			CLine & line = m_vecLine[ line_idx ].line;
			CLine & linenext = m_vecLine[ inext ].line;

			CVector3D v = line ^ linenext;
			CVector3D & v0 = m_pOutline->m_vecVertex[ Line_LastVertexIndex( line_idx ) ].v;
			CVector3D & v1 = m_pOutline->m_vecVertex[ Line_FirstVertexIndex( inext ) ].v;

			if ( v.IsInfinite() 
				|| ( int )line_loop.size() == 2
				|| !CheckDistance2D( v, v0, manager->m_dbCornerErrorTolerance ) 
				|| !CheckDistance2D( v, v1, manager->m_dbCornerErrorTolerance )
				|| !CheckAngle2D( v, line_idx, inext, manager->m_dbCosCornerAngleTolerance )) 
			{
				CLine temp_line;
				temp_line.p = ( v0 + v1 ) * 0.5;
				CVector3D temp_d0 = CVector3D( line.d[1], -line.d[0], 0.0 );
				CVector3D temp_d1 = CVector3D( linenext.d[1], -linenext.d[0], 0.0 );
				if ( temp_d0 * temp_d1 < 0.0 ) {
					temp_d1 *= -1.0;
				}
				temp_line.d = temp_d0 + temp_d1;
				temp_line.d.normalize();

				v = line ^ temp_line;
				if ( v.IsInfinite() || !CheckDistance2D( v, v0, manager->m_dbCornerErrorTolerance ) ) {
					outline.m_vecVertex.resize( outline.m_vecVertex.size() + 1 );
					outline.m_vecVertex.back().v = outline.m_cPlane.onplane( v0 );
				} else {
					outline.m_vecVertex.resize( outline.m_vecVertex.size() + 1 );
					outline.m_vecVertex.back().v = outline.m_cPlane.onplane( v );
				}

				v = temp_line ^ linenext;
				if ( v.IsInfinite() || !CheckDistance2D( v, v1, manager->m_dbCornerErrorTolerance ) ) {
					outline.m_vecVertex.resize( outline.m_vecVertex.size() + 1 );
					outline.m_vecVertex.back().v = outline.m_cPlane.onplane( v1 );
				} else {
					outline.m_vecVertex.resize( outline.m_vecVertex.size() + 1 );
					outline.m_vecVertex.back().v = outline.m_cPlane.onplane( v );
				}
			} else {
				outline.m_vecVertex.resize( outline.m_vecVertex.size() + 1 );
				outline.m_vecVertex.back().v = outline.m_cPlane.onplane( v );
			}

		}

		// second pass, produce lines
		// l[i] connects v[i.prev] & v[i]
		for ( int i = v_pointer; i < ( int )outline.m_vecVertex.size() - 1; i++ ) {
			outline.Add( i, i + 1 );
		}
		outline.Add( ( int )outline.m_vecVertex.size() - 1, v_pointer );
		v_pointer = ( int )outline.m_vecVertex.size();

	}

}

bool CAuxOutline::CheckDistance2D( CVector3D & v, CVector3D & v0, double corner_tolerance )
{
	CVector3D temp = v - v0;
	temp[2] = 0.0;
	return ( temp.length() <= corner_tolerance );
}

bool CAuxOutline::CheckAngle2D( CVector3D & v, int l0, int l1, double cos_angle_tolerance )
{
	CVector3D d0 = m_vecLine[ l0 ].line.d;
	if ( d0 * ( m_pOutline->m_vecVertex[ Line_FirstVertexIndex( l0 ) ].v - v ) < 0.0 )
		d0 *= -1.0;
	CVector3D d1 = m_vecLine[ l1 ].line.d;
	if ( d1 * ( m_pOutline->m_vecVertex[ Line_LastVertexIndex( l1 ) ].v - v ) < 0.0 )
		d1 *= -1.0;

	return ( d0 * d1 <= cos_angle_tolerance );
}